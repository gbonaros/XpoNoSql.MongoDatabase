// Part of the XpoNoSql.MongoDatabase provider.
// This file implements the IDataStore bridge that executes MongoDB aggregation pipelines and basic CRUD as part of the XPO ? MongoDB translation pipeline.
// Logic here must remain consistent with the rest of the provider.
// Part of the XpoNoSql.MongoDatabase provider.
// This file implements the IDataStore bridge that executes MongoDB aggregation pipelines and basic CRUD as part of the XPO → MongoDB translation pipeline.
// Logic here must remain consistent with the rest of the provider.
using DevExpress.Data.Filtering;
using DevExpress.Xpo;
using DevExpress.Xpo.DB;
using DevExpress.Xpo.DB.Exceptions;

using MongoDB.Bson;
using MongoDB.Driver;

using System;
using System.Globalization;
using System.Linq;

namespace XpoNoSQL.MongoDatabase.Core;

/// <summary>
/// Minimal <see cref="IDataStore"/> implementation that executes aggregation pipelines generated by <see cref="MongoSelectTranslator"/>.
/// Supports select via aggregation and basic insert/update/delete using the MongoDB driver; schema creation is not implemented.
/// </summary>
public sealed partial class MongoDataStore : IDataStore
{
    private readonly MongoSelectTranslator translator = new MongoSelectTranslator();
    private readonly MongoResultMaterializer materializer = new MongoResultMaterializer();
    private readonly IMongoDatabase database;
    private readonly AutoCreateOption autoCreateOption;

    /// <summary>
    /// Gets the last generated aggregation plan (for diagnostics).
    /// </summary>
    public MongoAggregationPlan LastPlan { get; private set; }

    /// <summary>
    /// Gets the auto-create option configured at initialization.
    /// </summary>
    public AutoCreateOption AutoCreateOption => autoCreateOption;

    /// <summary>
    /// Gets the connection string used by this data store.
    /// </summary>
    public string ConnectionString { get; }

    /// <summary>
    /// Performs schema updates by ensuring indexes; collections are not created.
    /// </summary>
    public UpdateSchemaResult UpdateSchema(bool doNotCreateIfFirstTableNotExist, params DBTable[] tables)
    {
        // we dont create tables/collections anyway
        // so we ignore doNotCreateIfFirstTableNotExist
        if (tables is not null)
        {
            foreach (DBTable table in tables)
            {
                if (table is null || string.IsNullOrEmpty(table.Name))
                    continue;

                EnsureIndexesForTable(database, table);
            }
        }

        return UpdateSchemaResult.SchemaExists;
    }
    private void EnsureIndexesForTable(IMongoDatabase db, DBTable table)
    {
        var coll = db.GetCollection<BsonDocument>(table.Name);
        var models = new List<CreateIndexModel<BsonDocument>>();
        var builder = Builders<BsonDocument>.IndexKeys;

        // -------------------------------------------------------
        // 1) XPO-defined indexes (always ASC because XPO doesn't
        //    expose sorting direction at DBIndex level)
        // -------------------------------------------------------
        if (table.Indexes != null)
        {
            foreach (var xpoIndex in table.Indexes)
            {
                if (xpoIndex.Columns == null || xpoIndex.Columns.Count == 0)
                    continue;

                IndexKeysDefinition<BsonDocument>? keys = null;

                for (int i = 0; i < xpoIndex.Columns.Count; i++)
                {
                    string col = xpoIndex.Columns[i]!;

                    if (i == 0)
                        keys = builder.Ascending(col);
                    else
                        keys = keys!.Ascending(col);
                }

                if (keys != null)
                {
                    var indexName =
                        string.IsNullOrEmpty(xpoIndex.Name)
                            ? $"idx_{table.Name}_{string.Join("_", xpoIndex.Columns)}"
                            : xpoIndex.Name;

                    models.Add(new CreateIndexModel<BsonDocument>(
                        keys,
                        new CreateIndexOptions
                        {
                            Unique = xpoIndex.IsUnique,
                            Name = indexName
                        }
                    ));
                }
            }
        }

        // -------------------------------------------------------
        // 2) Primary Key — use ALL PK columns (compound)
        // -------------------------------------------------------
        if (table.PrimaryKey != null &&
            table.PrimaryKey.Columns != null &&
            table.PrimaryKey.Columns.Count > 0)
        {
            IndexKeysDefinition<BsonDocument>? pkKeys = null;

            for (int i = 0; i < table.PrimaryKey.Columns.Count; i++)
            {
                string col = table.PrimaryKey.Columns[i]!;

                if (i == 0)
                    pkKeys = builder.Ascending(col);
                else
                    pkKeys = pkKeys!.Ascending(col);
            }

            if (pkKeys != null)
            {
                string pkName = $"pk_{table.Name}_{string.Join("_", table.PrimaryKey.Columns)}";

                models.Add(new CreateIndexModel<BsonDocument>(
                    pkKeys,
                    new CreateIndexOptions
                    {
                        Unique = true,   // PK must be unique
                        Name = pkName
                    }
                ));
            }
        }

        // -------------------------------------------------------
        // 3) Create all indexes (ignore conflicts)
        // -------------------------------------------------------
        if (models.Count > 0)
        {
            try
            {
                coll.Indexes.CreateMany(models);
            }
            catch (MongoCommandException mce)
                when (mce.CodeName == "IndexOptionsConflict" ||
                      mce.CodeName == "IndexKeySpecsConflict")
            {
                // Index exists with different options; ignore
                // to keep schema updates idempotent.
            }
            catch (Exception ex)
            {

            }
        }
    }

    /// <summary>
    /// Executes select statements via aggregation and materializes results.
    /// </summary>
    public SelectedData SelectData(params SelectStatement[] selects)
    {
        var results = new List<SelectStatementResult>();
        if (selects != null)
        {
            foreach (var select in selects)
            {
                var plan = translator.Translate(select);
                LastPlan = plan;

                var collection = database.GetCollection<BsonDocument>(plan.RootCollection);
                var pipeline = PipelineDefinition<BsonDocument, BsonDocument>.Create(plan.Pipeline);
                AggregateOptions options = GetAggregateOptions();
                var docs = collection.Aggregate(pipeline, options).ToList();
                var result = materializer.Materialize(select, docs, translator.LastContext);
                results.Add(result);
            }
        }

        return new SelectedData(results.ToArray());
    }

    private static AggregateOptions GetAggregateOptions()
    {
        var caseSensitive = XpoDefault.DefaultCaseSensitive;
        var culture = CultureInfo.CurrentCulture.TwoLetterISOLanguageName;

        var options = new AggregateOptions
        {
            Collation = new Collation(
                locale: culture,                   // we can make this configurable later
                strength: caseSensitive
                    ? CollationStrength.Tertiary   // case-sensitive
                    : CollationStrength.Secondary, // case-insensitive
                caseLevel: false                   // no need for caseLevel unless strength < 2
            )
        };
        return options;
    }

    /// <summary>
    /// Executes insert, update, and delete statements against MongoDB collections.
    /// </summary>
    public ModificationResult ModifyData(params ModificationStatement[] dmlStatements)
    {
        var identities = new List<ParameterValue>();
        if (dmlStatements == null || dmlStatements.Length == 0)
        {
            return new ModificationResult(identities);
        }

        foreach (var statement in dmlStatements)
        {
            switch (statement)
            {
                case InsertStatement insert:
                    {
                        var identity = DoInsert(insert);
                        if (identity is not null)
                        {
                            identities.Add(identity);
                        }
                    }
                    break;
                case UpdateStatement update:
                    DoUpdate(update);
                    break;
                case DeleteStatement delete:
                    DoDelete(delete);
                    break;
                default:
                    throw new NotSupportedException($"Modification statement '{statement?.GetType().Name}' is not supported.");
            }
        }

        return new ModificationResult(identities);
    }

    private ParameterValue DoInsert(InsertStatement insert)
    {
        var collection = database.GetCollection<BsonDocument>(insert.Table.Name);
        var document = new BsonDocument();

        // Populate fields from operands/parameters.
        for (int i = 0; i < insert.Operands.Count; i++)
        {
            var fieldName = GetFieldName(insert.Operands[i]);
            var value = GetValue(insert.Parameters[i]);
            document[fieldName] = value;
        }

        ParameterValue identityParam = null;
        if (insert.IdentityColumn is not null)
        {
            object identityValue;
            if (document.TryGetValue(insert.IdentityColumn, out var existing) && !existing.IsBsonNull)
            {
                identityValue = MongoBsonValueConverter.Convert(existing, insert.IdentityColumnType);
            }
            else
            {
                identityValue = GenerateIdentity(insert);
                document[insert.IdentityColumn] = BsonValue.Create(identityValue);
            }

            insert.IdentityParameter.Value = identityValue;
            identityParam = insert.IdentityParameter;
        }

        collection.InsertOne(document);
        return identityParam;
    }

    private void DoUpdate(UpdateStatement update)
    {
        var collection = database.GetCollection<BsonDocument>(update.Table.Name);
        var filter = BuildFilter(update.Table.Name, update.Alias, update.Condition);
        var setDoc = new BsonDocument();
        for (int i = 0; i < update.Operands.Count; i++)
        {
            var fieldName = GetFieldName(update.Operands[i]);
            var value = GetValue(update.Parameters[i]);
            setDoc[fieldName] = value;
        }

        if (setDoc.ElementCount == 0)
        {
            return;
        }

        var updateDoc = new BsonDocument("$set", setDoc);
        var result = collection.UpdateMany(filter, updateDoc);
        var affected = result.MatchedCount;
        if (update.RecordsAffected != 0 && update.RecordsAffected != affected)
        {
            throw new LockingException();
        }
    }

    private void DoDelete(DeleteStatement delete)
    {
        var collection = database.GetCollection<BsonDocument>(delete.Table.Name);
        var filter = BuildFilter(delete.Table.Name, delete.Alias, delete.Condition);
        var result = collection.DeleteMany(filter);
        if (delete.RecordsAffected != 0 && delete.RecordsAffected != result.DeletedCount)
        {
            throw new LockingException();
        }
    }

    private BsonDocument BuildFilter(string tableName, string alias, CriteriaOperator condition)
    {
        if (ReferenceEquals(condition, null))
        {
            return new BsonDocument();
        }

        var aliases = new MongoAliasRegistry(alias ?? string.Empty, tableName);
        var scope = new MongoExpressionScope(aliases);
        var dummySelect = new SelectStatement(new DBTable(tableName), alias);
        var context = new MongoTranslationContext(dummySelect, new MongoAggregationPlan(tableName), aliases, scope);
        var translator = new MongoCriteriaTranslator(context, scope);
        var match = translator.TranslateMatch(condition);
        return match ?? new BsonDocument();
    }

    private static string GetFieldName(CriteriaOperator operand)
    {
        if (operand is QueryOperand qo && !string.IsNullOrEmpty(qo.ColumnName))
        {
            return MongoAliasRegistry.NormalizeColumnName(qo.ColumnName);
        }

        return operand?.ToString() ?? string.Empty;
    }

    private static BsonValue GetValue(OperandValue operand)
    {
        if (operand is null || operand.Value is null || operand.Value is NullValue)
        {
            return BsonNull.Value;
        }

        if (operand.Value is Guid guid)
        {
            return new BsonBinaryData(guid, GuidRepresentation.Standard);
        }

        if (operand.Value is Guid?)
        {
            var nullableGuid = (Guid?)operand.Value;
            return nullableGuid.HasValue
                ? new BsonBinaryData(nullableGuid.Value, GuidRepresentation.Standard)
                : BsonNull.Value;
        }

        return BsonValue.Create(operand.Value);
    }

    private object GenerateIdentity(InsertStatement insert)
    {
        var counters = database.GetCollection<BsonDocument>("__xpo_counters");
        var filter = new BsonDocument("_id", insert.Table.Name);
        var update = new BsonDocument("$inc", new BsonDocument("seq", 1));
        var options = new FindOneAndUpdateOptions<BsonDocument, BsonDocument>
        {
            IsUpsert = true,
            ReturnDocument = ReturnDocument.Before
        };
        var result = counters.FindOneAndUpdate(filter, update, options);
        var seqValue = result?.GetValue("seq", BsonNull.Value);
        var seq = seqValue != null && !seqValue.IsBsonNull ? seqValue.ToInt64() + 1 : 1L;

        if (result is null)
        {
            var col = database.GetCollection<BsonDocument>(insert.Table.Name);

            // Scan max(identityColumn) if we had to create the counter entry.
            var existingFilter = Builders<BsonDocument>.Filter.And(
                Builders<BsonDocument>.Filter.Exists(insert.IdentityColumn, true),
                Builders<BsonDocument>.Filter.Ne(insert.IdentityColumn, BsonNull.Value));
            var sort = Builders<BsonDocument>.Sort.Descending(insert.IdentityColumn);
            var projection = Builders<BsonDocument>.Projection.Include(insert.IdentityColumn);

            var doc = col.Find(existingFilter)
                         .Sort(sort)
                         .Project(projection)
                         .Limit(1)
                         .FirstOrDefault();

            long maxValue = 0;
            if (doc != null && doc.TryGetValue(insert.IdentityColumn, out var v) && !v.IsBsonNull &&
                (v.IsInt64 || v.IsInt32 || v.IsDouble || v.IsDecimal128))
                maxValue = v.ToInt64();

            var desired = maxValue + 1;
            if (desired > seq)
            {
                var maxUpdate = new BsonDocument("$max", new BsonDocument("seq", desired));
                var recalibrated = counters.FindOneAndUpdate(
                    filter,
                    maxUpdate,
                    new FindOneAndUpdateOptions<BsonDocument, BsonDocument> { ReturnDocument = ReturnDocument.After });
                var recalibratedValue = recalibrated?.GetValue("seq", BsonNull.Value);
                seq = recalibratedValue != null && !recalibratedValue.IsBsonNull ? recalibratedValue.ToInt64() : desired;
            }
        }

        switch (insert.IdentityColumnType)
        {
            case DBColumnType.Int32:
                return (int)seq;
            case DBColumnType.Int64:
                return seq;
            default:
                throw new NotSupportedException($"Identity column type '{insert.IdentityColumnType}' is not supported for Mongo identity generation.");
        }
    }

}





